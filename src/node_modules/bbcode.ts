// Based on article https://habr.com/ru/post/224081

interface PatternResult {
    res: any,
    end: number
}

class Pattern {
    constructor(exec: (str: string, pos: number) => PatternResult) {
        this.exec = exec;
    }

    exec: (str: string, pos: number) => PatternResult;

    then(transform: any): Pattern {
        return new Pattern((str: string, pos: number) => {
            const r = this.exec(str, pos);
            return r && { res: transform(r.res), end: r.end };
        });
    }
}

function txt(text: string): Pattern {
    return new Pattern((str: string, pos: number) => {
        if (str.substring(pos, text.length) == text) {
            return { res: text, end: pos + text.length }
        }
    });
}

function rgx(regexp: RegExp): Pattern {
    return new Pattern((str: string, pos: number) => {
        const m = regexp.exec(str.slice(pos));

        if (m && m.index == 0) {
            return { res: m[0], end: pos + m[0].length }
        }
    });
}

function opt(pattern: Pattern): Pattern {
    return new Pattern((str: string, pos: number) => {
        return pattern.exec(str, pos) || { res: void 0, end: 0 };
    });
}

function exc(pattern: Pattern, except: Pattern): Pattern {
    return new Pattern((str: string, pos: number) => {
        return !except.exec(str, pos) && pattern.exec(str, pos);
    });
}

function any(...patterns: Pattern[]): Pattern {
    return new Pattern((str: string, pos: number) => {
        for (let r: PatternResult, i = 0; i < patterns.length; i++) {
            if (r = patterns[i].exec(str, pos)) {
                return r;
            }
        }
    });
}

function seq(...patterns: Pattern[]): Pattern {
    return new Pattern((str: string, pos: number) => {
        let res = [];
        let end = pos;

        for (let i = 0; i < patterns.length; i++) {
            let r = patterns[i].exec(str, pos);

            if (!r) return;

            res.push(r.res);
            end = r.end;
        }

        return { res: res, end: end };
    });
}

function rep(pattern: Pattern, separator: Pattern): Pattern {
    const separated = !separator ? pattern : seq(separator, pattern).then(r => r[1]);

    return new Pattern((str: string, pos: number) => {
        const res = [];
        let end = pos;
        let r = pattern.exec(str, end);

        while (r && r.end > end) {
            res.push(r.res);
            end = r.end;
            r = separated.exec(str, end);
        }

        return { res: res, end: end }
    })
}

export function parse(text: string): string {
    console.log("source", text)
    const res = txt("[b]").exec(text, 0)
    console.log(res)
    return text;
}

function fixYouTubeLink(link: string) {
    return "https://www.youtube.com/embed/" + link.match(/([^\/]*$)/)[0];
}
