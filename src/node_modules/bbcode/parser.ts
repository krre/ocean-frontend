import { Pattern, txt, rgx, seq, rep, any, opt } from "./pattern"

export const name = rgx(/[a-z]+/i).then(s => s.toLowerCase());
export const char = rgx(/[^"\[]/i);
export const wsp = rgx(/\s+/);
export const text = rep(char).then(r => r.join(''));
export const quoted = seq(txt('"'), rep(char), txt('"')).then(r => r[1].join(''));
export const attr = seq(name, txt("="), quoted).then(r => ({ name: r[0], value: r[2] }));

export const attrs = rep(attr, wsp).then(r => {
    const m = {};
    r.forEach(a => (m[a.name] = a.value));
    return m;
});

export const open = seq(txt("["), name, opt(seq(txt("="), quoted)), opt(seq(wsp, attrs)), txt("]")).then(r => {
    const result = {
        name: r[1],
        attrs: {}
    }

    if (r[2]) {
        result.attrs[result.name] = r[2][1]
    }

    if (r[3]) {
        const a = r[3][1]

        for (let prop in a) {
            result.attrs[prop] = a[prop]
        }
    }

    return result;
});

export const close = seq(txt("[/"), name, txt("]")).then(r => r[1]);

const subnode = new Pattern("subnode", (str: string, pos: number) => node.exec(str, pos));
export const mix = rep(any(text, subnode));
export const node = seq(open, mix, close).then(r => ({ name: r[0].name, attrs: r[0].attrs, nodes: r[1] }));
export const doc = mix.then(r => ({ name: "doc", attrs: {}, nodes: r }));
