export interface PatternResult {
    res: any,
    end: number
}

export class Pattern {
    name: string;

    constructor(name: string, exec: (str: string, pos: number) => PatternResult) {
        this.name = name;
        this.exec = exec;
    }

    exec: (str: string, pos: number) => PatternResult;

    then(transform: any): Pattern {
        return new Pattern(this.name, (str: string, pos: number) => {
            const r = this.exec(str, pos);
            return r && { res: transform(r.res), end: r.end };
        });
    }
}

export function txt(text: string): Pattern {
    return new Pattern("txt", (str: string, pos: number) => {
        if (str.substring(pos, pos + text.length) == text) {
            return { res: text, end: pos + text.length }
        }
    });
}

export function rgx(regexp: RegExp): Pattern {
    return new Pattern("rgx", (str: string, pos: number) => {
        const m = regexp.exec(str.slice(pos));

        if (m && m.index == 0) {
            return { res: m[0], end: pos + m[0].length }
        }
    });
}

export function opt(pattern: Pattern): Pattern {
    return new Pattern("opt", (str: string, pos: number) => {
        return pattern.exec(str, pos) || { res: void 0, end: pos };
    });
}

export function exc(pattern: Pattern, except: Pattern): Pattern {
    return new Pattern("exc", (str: string, pos: number) => {
        return !except.exec(str, pos) && pattern.exec(str, pos);
    });
}

export function any(...patterns: Pattern[]): Pattern {
    return new Pattern("any", (str: string, pos: number) => {
        for (let r: PatternResult, i = 0; i < patterns.length; i++) {
            if (r = patterns[i].exec(str, pos)) {
                return r;
            }
        }
    });
}

export function seq(...patterns: Pattern[]): Pattern {
    return new Pattern("seq", (str: string, pos: number) => {
        let res = [];
        let end = pos;

        for (let i = 0; i < patterns.length; i++) {
            let r = patterns[i].exec(str, end);

            if (!r) return;

            res.push(r.res);
            end = r.end;
        }

        return { res: res, end: end };
    });
}

export function rep(pattern: Pattern, separator?: Pattern): Pattern {
    const separated = !separator ? pattern : seq(separator, pattern).then(r => r[1]);

    return new Pattern("rep", (str: string, pos: number) => {
        const res = [];
        let end = pos;
        let r = pattern.exec(str, end);

        while (r && r.end > end) {
            res.push(r.res);
            end = r.end;
            r = separated.exec(str, end);
        }

        return { res: res, end: end }
    })
}
